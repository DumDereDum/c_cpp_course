## Исключения

- **Генерация сообщения об ошибке (throw)**
- **Перехват этих сообщений (catch)**
- В программе может одновременно существовать только одно исключение.

### Синтаксис

```c++
try {
    // код, в котором может возникнуть исключение
    throw Exception;
} catch(Exception) {
    // обработка исключения
}
```

- «выбрасываем» исключения
- «перехватываем» исключения

### Класс Vector с исключениями

Класс `Vector` представляет собой динамический массив целых чисел, хранящийся в динамической памяти. Он содержит приватные члены `int* p`, указывающий на динамически выделенный массив, и `int sz`, представляющий размер массива. Публично доступны константа `max`, определяющая максимальный размер массива, а также вложенные классы `Range` и `Size`, используемые для управления диапазонами и размерами. Конструктор `Vector` позволяет инициализировать массив заданным размером, по умолчанию размер устанавливается в 1000. Перегружен оператор `[]` обеспечивает доступ к элементам массива по индексу и возвращает ссылку на элемент. Деструктор освобождает память, выделенную для массива.

```c++
#include <iostream>

class Vector {
    int* p;
    int sz;
public:
    enum { max = 32000 };
    class Range {
    public:
        int index;
        Range(int i) : index(i) { }
    };  
    class Size {
    public:
        int index;
        Size(int i) : index(i) { }
    };   
    Vector(int sz = 1000);
    int& operator[](int i);
    ~Vector();
};

Vector::~Vector() {
    delete[] p;
}

int& Vector::operator[](int i) {
    if (i < 0 || sz <= i) throw Range(i);
    return p[i];
}

```

## Исключения в конструкторах

Если в конструкторе произошло исключение, то объект не будет создан.

### Исключение в конструкторе

* Замените `Vector v(5)` на `Vector v(-5)`
* Замените `for (int i = 0; i < 5; ++i)` на `for (int i = 0; i < 20; ++i)`

```c++
Vector::Vector(int sz) {
    if (sz < 0 || max < sz) throw Size(sz);
    if(!sz) {
        p = 0;
        Vector::sz = sz;
        return;
    }
    p = new int[Vector::sz = sz];
    for(int i = 0; i < sz; i++)
        p[i] = i;
}

int main() {
    try {
        Vector v(5);
        for (int i = 0; i < 5; ++i) {
            std::cout << "v[" << i << "] = " << v[i] << std::endl;
        }
    } catch (Vector::Range& r) {
        std::cerr << "Index out of range: " << r.index << std::endl;
    } catch (Vector::Size& s) {
        std::cerr << "Invalid size: " << s.index << std::endl;
    }
    return 0;
}
```

## Исключения и инициализация полей

* Замените `Date hire_date(2024, 3, 15);` на `Date hire_date(2224, 3, 15);`

```c++
#include <iostream>

class Date {
public:
    class Bad_Date {};
    Date(int year, int month, int day) {
        if (year < 1900 || year > 2100 || month < 1 || month > 12 || day < 1 || day > 31) {
            throw Bad_Date();
        }
        // Инициализация даты
    }
};

class Employee {
    Date hire_date;
public:
    Employee(Date d) try : hire_date(d) {
        // Тело конструктора
    } catch (Date::Bad_Date) {
        std::cerr << "Invalid hire date!" << std::endl;
        // Обработка неправильной даты
    }
};

int main() {
    try {
        Date hire_date(2024, 3, 15);
        Employee employee(hire_date);
        // Продолжение работы с объектом employee
    } catch (...) {
        std::cerr << "An error occurred!" << std::endl;
    }
    return 0;
}

```

## Исключения в деструкторах

Деструктор объекта вызывается в двух случаях: при нормальных условиях и когда объект удаляется механизмом обработки исключений. Если при уже сгенерированном исключении в деструкторе также генерируется исключение, то при передаче управления вызывающей функции C++ сразу же запускает функцию terminate.

### Исключение не должно покинуть деструктор

```c++
Vector::~Vector() {
    try {
        // ...
    } catch(...) {
        // Предотвратить выход исключения
    }
}
```

Этот код пытается предотвратить выход исключения из деструктора класса `Vector` путем использования блока `try-catch` внутри деструктора. Идея заключается в том, чтобы поймать любое исключение, возникающее во время выполнения кода внутри деструктора, и предотвратить его распространение дальше.

Однако, важно понимать, что в стандарте C++ запрещено выбрасывать исключения из деструкторов, когда исключение уже обрабатывается. Такое поведение приводит к неопределенному состоянию программы и может вызвать утечку ресурсов или другие серьезные проблемы.

Таким образом, использование `try-catch` внутри деструктора не рекомендуется, и вместо этого следует убедиться, что все исключения обрабатываются внутри методов, которые могут их вызвать, или внутри функции `main()` для глобальной обработки исключений.

### Проверка на уже существующее исключение

```c++
Vector::~Vector() {
    if(!std::uncaught_exception()) {
        throw Exception();
    }
}
```

Этот код в деструкторе класса `Vector` использует функцию `std::uncaught_exception()` для проверки наличия уже существующего исключения в момент вызова деструктора. Если такого исключения нет (то есть, программный код находится в процессе обработки другого исключения), деструктор выбрасывает новое исключение типа `Exception`.

Однако, использование `std::uncaught_exception()` для принятия решения о выбросе исключения в деструкторе - это плохая практика. Функция `std::uncaught_exception()` была предназначена для использования в старом стандарте C++ для предотвращения распространения исключений в некоторых сценариях. В современном стандарте C++, рекомендуется избегать использования `std::uncaught_exception()`, так как она может привести к неожиданному поведению и нарушению гарантий безопасности исключений.

Вместо этого, лучшим подходом будет явная обработка исключений в коде, где исключения могут возникнуть, и использование блока `try-catch` для обработки исключений там, где это необходимо.

#### Зачем это надо

Проверка на наличие уже существующего исключения может быть полезной в определенных сценариях, где важно избежать распространения новых исключений, если уже происходит обработка другого исключения. Это может быть необходимо для предотвращения дополнительных проблем, таких как утечка ресурсов или неконсистентное состояние программы. Некоторые случаи, когда такая проверка может быть полезной:

1. **Обработка исключений в деструкторах**: Если деструктор выбрасывает исключение, когда уже в процессе обработки другого исключения, это может вызвать катастрофическое завершение программы. Проверка наличия уже существующего исключения позволяет избежать такого поведения.

2. **Многопоточные приложения**: В многопоточных приложениях контекст выполнения может быть неопределенным во время обработки исключений. Проверка на наличие уже существующего исключения помогает избежать конфликтов и неопределенного поведения.

3. **Освобождение ресурсов**: Если уже происходит обработка исключения в момент удаления объекта или освобождения ресурсов в деструкторе, выбрасывание нового исключения может привести к утечке ресурсов. Проверка на наличие уже существующего исключения позволяет избежать этой ситуации.

## Исключение в методе класса

```c++
int& Vector::operator [](int i) {
    try {
        if(i < 0 || sz <= i) throw Range(i);
        return p[i];
    } catch(...) {
        std::cout << "Aha" << std::endl;
    }
}
```

## Группировка исключений

```c++
class Exception {};

class VectorError: public Exception {};
class Overflow: public VectorError{};
class WrongSize: public VectorError{};

class StackError: public Exception {};
class Underflow: public StackError{};
```

Этот код демонстрирует систему иерархии исключений в C++, используемую для организации обработки ошибок в приложении. `Exception` является базовым классом для всех исключений, от которого наследуются специфические классы исключений, такие как `VectorError` и `StackError`, представляющие разные категории ошибок. `VectorError` в свою очередь является родителем для более конкретных исключений, связанных с операциями над векторами, например `Overflow` (переполнение) и `WrongSize` (некорректный размер), а `StackError` — для исключений стека, таких как `Underflow` (исчерпание стека). Эта структура позволяет обрабатывать ошибки более гранулированно, ловя как общие типы исключений, так и конкретные ситуации.

Для расширения примера и улучшения понимания, добавим использование этих исключений в контексте классов `Vector` и `Stack`, включая методы, которые могут генерировать исключения:

```c++
class Vector {
    int* p;
    int sz;
public:
    Vector(int sz) : sz(sz), p(new int[sz]) {
        if(sz > max) throw Overflow();
        if(sz < 0) throw WrongSize();
    }

    int& operator[](int i) {
        if(i < 0 || i >= sz) throw Range(i);
        return p[i];
    }

    ~Vector() {
        delete[] p;
    }
};

class Stack {
    int* data;
    int top;
    int capacity;
public:
    Stack(int capacity) : capacity(capacity), top(-1), data(new int[capacity]) {}

    void push(int value) {
        if(top == capacity - 1) throw Overflow();
        data[++top] = value;
    }

    int pop() {
        if(top == -1) throw Underflow();
        return data[top--];
    }

    ~Stack() {
        delete[] data;
    }
};

int main() {
    try {
        Vector v(-1); // попытка создать вектор с некорректным размером
    } catch(const VectorError& e) {
        // Обработка ошибок вектора
    }

    try {
        Stack s(10);
        s.pop(); // попытка извлечь элемент из пустого стека
    } catch(const StackError& e) {
        // Обработка ошибок стека
    }
}
```

## Повторная генерация исключений

Этот код демонстрирует механизм повторной генерации исключений в C++, который позволяет передать обработку исключения на более высокий уровень иерархии вызовов, если текущий обработчик не может или не должен полностью обрабатывать исключение. В функции `f()`, сначала происходит попытка обработать исключение `Underflow`, которое является подклассом `Exception`. Если функция `canHandleItCompletely(re)` возвращает `false`, то это означает, что текущая функция не способна полностью обработать исключение, и оно повторно выбрасывается с помощью оператора `throw;` без аргументов. Это приведет к передаче исключения в вызывающий код, который может попытаться обработать его в блоке `try` функции `g()`.

Для улучшения примера и демонстрации полноты концепции, давайте добавим немного контекста и реализации вспомогательных функций:

```c++
#include <iostream>
#include <exception>

// Базовый класс исключений
class Exception : public std::exception {};

// Исключения, связанные со стеком и вектором
class StackError : public Exception {};
class VectorError : public Exception {};
class Underflow : public StackError {};

bool canHandleItCompletely(const Exception& re) {
    // Здесь могла бы быть логика для проверки,
    // способна ли функция полностью обработать исключение
    return false; // Для примера всегда возвращает false
}

void doWhatYouCanDo(const Exception& re) {
    // Выполнение частичной обработки исключения
    std::cout << "Частичная обработка исключения." << std::endl;
}

void f() {
    try {
        // Произвольный код, который может сгенерировать исключение
        throw Underflow();
    } catch (Exception& re) {
        if (canHandleItCompletely(re)) {
            // Полная обработка исключения
            std::cout << "Исключение полностью обработано." << std::endl;
            return;
        } else {
            doWhatYouCanDo(re);
            throw; // Повторная генерация исключения
        }
    }
}

void g() {
    try {
        f();
    } catch (StackError& re) {
        std::cout << "Обработка StackError в функции g()." << std::endl;
    } catch (VectorError& re) {
        std::cout << "Обработка VectorError в функции g()." << std::endl;
    }
}

int main() {
    try {
        g();
    } catch (...) {
        std::cout << "Неизвестное исключение поймано в main." << std::endl;
    }
    return 0;
}
```


## Перехват исключений

```c++
try {
    // ...
} catch (Overflow& re) {
    // обработка Overflow
} catch (VectorError& re) {
    // обработка VectorError
} catch (Exception& re) {
    // обработка Exception
} catch (...) {
    // обработка всех остальных исключений
}
```

## Встроенные типы исключений

Используйте стандартные библиотеки `exception` и `stdexcept` для работы с встроенными типами исключений.
