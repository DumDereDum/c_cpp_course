# Шаблоны и наследование

- Шаблон класса может быть производным от шаблона класса.
- Шаблон класса может являться производным от обычного класса.
- Шаблон класса может быть производным от специализации шаблона класса.
- Обычный класс может быть производным от специализации шаблона класса.

## Примеры

### Пример 1
```cpp
template<class T>
class A {};

template<class T>
class B : public A<T> {};

int main() {
    B<int> b;
}
```
Этот код определяет два шаблонных класса: `A` и `B`. Класс `B` наследуется от класса `A`. В функции `main` создается объект `b` класса `B<int>`. 

Основная идея кода - демонстрация шаблонного наследования в C++, где класс `B` наследует от шаблонного класса `A` и использует его параметр `T`.

### Пример 2
```cpp
template<class T>
class A {};

template<class T>
class B : public A {}; // ошибка

int main() {
    B<int> b;
}
```

### Пример 3
```cpp
template<class T>
class A {};

template<class T>
class B : public A<int> {};

int main() {
    B<double> b;
}
```

Этот код определяет два шаблонных класса: `A` и `B`. Класс `B` наследуется от класса `A<int>`, используя `int` в качестве аргумента шаблона. В функции `main` создается объект `b` класса `B<double>`, что означает, что `T` в классе `A` будет заменен на `int`, а `T` в классе `B` будет заменен на `double`.

Основная идея кода - демонстрация использования шаблонов в наследовании классов в C++.

### Пример 4
```cpp
template<class T>
class A {};

template class B : public A<int> {};

int main() {
    B b;
}
```
В данном коде происходит попытка явного инстанцирования шаблонного класса `B`, но так как `B` сам не является шаблоном, компилятор выдает ошибку.

Ключевое слово `template` используется для явного инстанцирования шаблонных классов или функций. Однако, в случае с классом `B`, оно неправильно применено, потому что `B` сам не является шаблоном, только его базовый класс `A<int>` является шаблоном. 
