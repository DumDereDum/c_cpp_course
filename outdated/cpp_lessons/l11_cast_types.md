# Приведение типов

## Операции приведения типов

- `reinterpret_cast<целевой_тип>(аргумент)`
- `const_cast<целевой_тип>(аргумент)`
- `static_cast<целевой тип>(аргумент)`
- `dynamic_cast<целевой_тип>(аргумент)`

## `reinterpret_cast`

`reinterpret_cast` — это оператор приведения типов в C++, который используется для переинтерпретации битового представления одного типа данных в другой, позволяя прямые манипуляции на уровне памяти. Это может быть применено для преобразования указателей одного типа в указатели другого типа, приведения указателей к целочисленным типам и наоборот, а также для преобразования между различными типами ссылок. `reinterpret_cast` не проверяет логическую совместимость типов, что делает его мощным, но потенциально опасным инструментом, поскольку неправильное использование может привести к неопределённому поведению программы. Он широко используется в низкоуровневом программировании, например, при работе с аппаратным обеспечением или системными вызовами, где требуется прямой доступ к памяти.

### Аргумент и Целевой тип

- ссылка        -> ссылка, указатель, числовые типы
- указатель     -> ссылка, указатель, числовые типы
- числовые типы -> ссылка, указатель, числовые типы

Приведение несвязанных типов.

### Использование `reinterpret_cast`

```cpp
#include <iostream>
#include <cstdint>

int main() {
    int i = 7;
    int *ip = &i;
    int temp = reinterpret_cast<uintptr_t>(ip);

    std::cout << "Pointer value is " << ip << std::endl;
    std::cout << "Representation of a pointer as int is " << std::hex << temp << std::endl;
    std::cout << "Convert it back and dereference: " << *reinterpret_cast<int*>(temp) << std::endl;
    return 0;
}
```

* `int temp = reinterpret_cast<int>(ip);` - Здесь используется `reinterpret_cast` для приведения указателя `ip` к целочисленному типу `int`. Это довольно низкоуровневая операция, которая фактически интерпретирует адрес памяти, на который указывает `ip`, как целое число. Результат присваивается переменной `temp`. Это действие может быть использовано для выполнения операций на уровне битов с адресами памяти или в специфических случаях, когда нужно работать с самим адресом, как с числом.

* `std::cout << "Convert it back and dereference: " << *reinterpret_cast<int*>(temp) << std::endl;` - Здесь `temp`, который содержит адрес в форме целого числа, снова приводится к типу `int*` (указатель на `int`) с использованием `reinterpret_cast`. После этого происходит разыменование этого указателя (`*`) для получения значения, на которое он указывает, и это значение выводится. Так как `temp` содержит адрес переменной `i`, то разыменование возвращает значение `i`, то есть 7.


```cpp
class A {};
class B {};

int main() {
    A a;
    A &ref = a;
    A *p = &a;
    B &r = reinterpret_cast<B&>(*p);
    B b;
    ref = reinterpret_cast<A&>(b);
    B *pp = reinterpret_cast<B*>(p);
}
```

* `B &r = reinterpret_cast<B&>(*p);` - Здесь происходит приведение объекта, на который указывает `p` (т.е. объект `a`), к ссылке на тип `B`. Полученная ссылка сохраняется в переменной `r`. Это действие не безопасно, поскольку `A` и `B` являются различными типами и могут иметь разное представление в памяти. `reinterpret_cast` здесь используется для принудительного интерпретирования блока памяти объекта `A` как если бы он был объектом `B`, что может привести к неопределенному поведению при доступе к членам через `r`.

* `ref = reinterpret_cast<A&>(b);` - Происходит приведение объекта `b` к типу `A&` и присваивание его ссылке `ref`. Поскольку `ref` является ссылкой на `a`, этот код фактически пытается интерпретировать объект `b` как объект `A` и присвоить его `a`. Это неверно и может привести к неопределенному поведению, так как `A` и `B` могут иметь различное внутреннее устройство.

* `B *pp = reinterpret_cast<B*>(p);` - Указатель `p` на объект типа `A` приводится к типу указателя на `B`. Теперь `pp` предположительно указывает на объект типа `B`, но на самом деле указывает на объект `a` типа `A`. Это приведение типов также потенциально опасно и может привести к неопределенному поведению, если через `pp` будет осуществлен доступ к членам объекта.

## `const_cast`

`const_cast` - это оператор в C++ для удаления или добавления квалификатора `const` или `volatile` с переменной. Он обеспечивает возможность изменения квалификатора `const` переменной, что может быть полезно, например, когда вы работаете с старым кодом, который не явно объявляет переменные как `const`, но вы уверены, что операция, которую вы собираетесь выполнить, не изменит значения переменной. Однако необходимо быть осторожным при использовании `const_cast`, поскольку это может привести к неопределенному поведению или нарушению константности в программе, если изменение `const` используется неправильно.

### Аргумент и Целевой тип

- `const type` -> `type`
- `volatile type` -> `type`

### Использование `const_cast`

```cpp
#include <iostream>
#include <cstring>

int main() {
    const char *ip = nullptr;
    ip = new char[20];
    strcpy(const_cast<char*>(ip), "New const string");
    std::cout << ip << std::endl;

    strcpy(const_cast<char*>(ip), "Test");
    std::cout << ip << std::endl;

    delete[] ip;

    return 0;
}
```

* С помощью функции `strcpy` и оператора `const_cast<char*>(ip)`, происходит копирование строки `"New const string"` в память, на которую указывает `ip`. `const_cast` используется для временного снятия константности с указателя `ip`, чтобы сделать возможной запись в память. Несмотря на то, что `ip` объявлен как указатель на `const char`, фактически выделенная память не является константной, и в неё можно записывать данные.

* Содержимое памяти, на которую указывает `ip`, выводится в стандартный вывод. В этот момент оно содержит строку `"New const string"`.

* Аналогично, строка `"Test"` копируется в ту же самую память, заменяя предыдущее содержимое. Это демонстрирует возможность повторного использования выделенной памяти для хранения новых данных.

Пример с функцией:

```cpp
#include <iostream>
#include <string>

class Employee {
    std::string name;
public:
    Employee(const std::string& initialName) : name(initialName) {}
    void new_name(const std::string& newName) { name = newName; }
    void print_name() const { std::cout << "Employee name: " << name << std::endl; }
};

void f(const Employee* pemp) {
    const_cast<Employee*>(pemp)->new_name("Petya");
}

int main() {
    const Employee emp("Vasya");
    f(&emp);
    emp.print_name();
    return 0;
}
```

* Внутри функции `f`, оператор `const_cast<Employee*>(pemp)` используется для временного снятия константности с указателя `pemp`. Это позволяет изменить объект `Employee`, на который указывает `pemp`, даже если он был объявлен как константный. После снятия константности вызывается метод `new_name("Petya")` на модифицированном указателе, что изменяет имя сотрудника на "Petya".

## `static_cast`

`static_cast` - это оператор в C++, используемый для выполнения явного преобразования типов во время компиляции. Он обеспечивает безопасное и контролируемое преобразование между типами, которые связаны отношениями наследования, поддерживаются языком, а также между типами, которые не связаны отношениями наследования, но совместимы друг с другом. Например, `static_cast` может использоваться для преобразования указателей на базовый класс в указатели на производный класс, а также для выполнения преобразования между числовыми типами данных, такими как `int` в `double`. Однако использование `static_cast` должно быть осторожным, поскольку оно не выполняет проверок во время выполнения и может привести к потере данных или неопределенному поведению, если преобразование некорректно.

### Аргумент и Целевой тип

- Ссылка на объекты классов находящихся в иерархических отношениях
- Указатель на объекты классов находящихся в иерархических отношениях
- числовые типы

### Использование `static_cast`

Пример с классами:

```cpp
#include <iostream>
#include <string>

class Date {
public:
    Date(int d = 1, int m = 1, int y = 1970) {}
};

class Employee {
protected:
    std::string name;
    double salary;
public:
    Employee(const std::string& n = "", double s = 0) : name(n), salary(s) {}
    virtual bool SetBonus() { return false; }
    double GetSalary() const { return salary; }
};

class Manager : public Employee {
    struct Subordinate {
        Employee* emp;
        std::string todo;
        Date start, finish, deadline;
    };

public:
    Manager() : arr(nullptr) {}
    bool SetBonus() override { return true; }
private:
    Subordinate **arr;
protected:
    Subordinate* Arr(int i) { return nullptr; }
};

class Supervisor : public Employee {
public:
    bool SetBonus(Manager *man) {
        int i = 0;
        if(static_cast<Manager*>(man->Arr(i)->emp)->SetBonus()) {
            man->Arr(i)->emp->SetBonus();
            return true;
        }
        return false;
    }
};

int main() {
    Manager manager;
    Supervisor supervisor;
    supervisor.SetBonus(&manager);
    return 0;
}
```

* В функции `SetBonus` класса `Supervisor`, мы пытаемся назначить бонус менеджеру (`Manager`), который является одним из подчинённых. Для этого используется статическое приведение типа (`static_cast`) подчинённого (`Employee`) к типу `Manager` для доступа к его методу `SetBonus`. После приведения типа вызывается метод `SetBonus` для объекта менеджера. Если вызов метода `SetBonus` возвращает `true`, это означает, что бонус успешно назначен менеджеру. В данном случае, функция `Arr` предполагается возвращать подчинённого по индексу `i`, но поскольку реализация возвращает `nullptr`, реальной логики назначения бонуса и обработки подчинённых в коде не реализовано. Это просто демонстрация механизма работы с наследованием и приведением типов в C++.


## `dynamic_cast`

`dynamic_cast` в C++ - это оператор, который обеспечивает безопасное преобразование типов в иерархии классов во время выполнения. Он используется для проверки и преобразования указателей или ссылок на базовые классы к указателям или ссылкам на производные классы, позволяя программе проверить правильность преобразования перед выполнением операций с объектами производных классов. Если преобразование невозможно при безопасном использовании, `dynamic_cast` возвращает нулевой указатель для указателей или ссылки на объект, предотвращая таким образом ошибки времени выполнения.

### Аргумент и Целевой тип

- Ссылка на объект базового класса -> Ссылка на объект производного класса (выдаёт `bad_cast` при ошибке)
- Указатель на объект базового класса -> Указатель на объект производного класса (возвращает `nullptr` при ошибке)

### Использование `dynamic_cast`

Пример с базовым и производным классами:

```cpp
#include <iostream>
#include <string>

class Employee {
public:
    virtual ~Employee() {}
};

class Date {
public:
    Date() {}
};

class Manager : public Employee {
public:
    Manager() : arr(nullptr) {}
    virtual ~Manager() {}
    virtual bool SetBonus() override {
        std::cout << "Bonus set for Manager\n";
        return true;
    }
private:
    struct Subordinate {
        Employee* emp;
        std::string todo;
        Date start, finish, deadline;
    };
    Subordinate **arr;
};

int main() {
    Employee *arr[10];
    for(int i = 0; i < 10; ++i) {
        Manager* p = dynamic_cast<Manager*>(arr[i]);
        if(p != nullptr) {
            p->SetBonus();
        }
    }
    return 0;
}

```

* Использование `dynamic_cast` в данном контексте кода служит для реализации позднего связывания, то есть определения типа объекта во время выполнения программы. В вашем примере кода это используется для безопасного приведения типа указателя с базового класса `Employee` к производному классу `Manager`. Вот как это работает и для чего это нужно:
