Ниже приведён подробный план лекции по C, посвящённой структурам. 
1. **Введение в структуры**  
   - Что такое структура в C: пользовательский тип данных, объединяющий несколько переменных (поля) разных типов.  
   - Синтаксис объявления структуры.  
   - Пример простой структуры для точки на плоскости:
     ```c
     struct Point {
         int x;
         int y;
     };
     ```
   - Работа с переменными структур: создание экземпляров, доступ к полям, оператор `.`.

2. **Тип `struct` и `typedef`**  
   - Использование `typedef` для упрощения записи:
     ```c
     typedef struct Point {
         int x;
         int y;
     } Point;
     ```
   - Теперь можно просто писать `Point p;`

3. **Структуры в качестве полей других структур**  
   - Пример: Структура для описания прямоугольника:
     ```c
     typedef struct {
         Point topLeft;
         Point bottomRight;
     } Rectangle;
     ```
   - Обращение к подполям:
     ```c
     Rectangle r;
     r.topLeft.x = 0;
     r.topLeft.y = 0;
     r.bottomRight.x = 10;
     r.bottomRight.y = 20;
     ```

4. **Передача структур в функции и возвращение из функций**  
   - Пример функции, возвращающей структуру `Point`:
     ```c
     Point createPoint(int x, int y) {
         Point p;
         p.x = x;
         p.y = y;
         return p;
     }
     ```
   - Пример функции, принимающей структуру:
     ```c
     void printPoint(Point p) {
         printf("Point(%d, %d)\n", p.x, p.y);
     }
     ```

5. **Динамическое выделение памяти под структуры**  
   - Использование `malloc` для выделения памяти под структуру:
     ```c
     Point* p = malloc(sizeof(Point));
     p->x = 5;
     p->y = 10;
     free(p); // после использования не забыть освободить память
     ```

6. **Связный список (односвязный)**  
   - Зачем нужны связные списки: структура данных для динамических наборов элементов, эффективное добавление/удаление в начало списка.
   - Определение структуры узла односвязного списка:
     ```c
     typedef struct Node {
         int data;
         struct Node* next;
     } Node;
     ```
   - Инициализация списка (изначально `NULL`).
   - Функции для работы со списком:
     - Добавление элемента в начало:
       ```c
       Node* pushFront(Node* head, int value) {
           Node* newNode = malloc(sizeof(Node));
           newNode->data = value;
           newNode->next = head;
           return newNode;
       }
       ```
     - Вывод списка:
       ```c
       void printList(Node* head) {
           Node* current = head;
           while (current != NULL) {
               printf("%d -> ", current->data);
               current = current->next;
           }
           printf("NULL\n");
       }
       ```
     - Освобождение памяти:
       ```c
       void freeList(Node* head) {
           Node* current = head;
           while (current != NULL) {
               Node* tmp = current;
               current = current->next;
               free(tmp);
           }
       }
       ```
   
   - Демонстрация: Создадим список, добавим несколько элементов и выведем его.

7. **Двусвязный список**  
   - Отличия двусвязного списка от односвязного: узлы хранят указатели на предыдущий и следующий элементы.
   - Определение структуры узла двусвязного списка:
     ```c
     typedef struct DNode {
         int data;
         struct DNode* prev;
         struct DNode* next;
     } DNode;
     ```
   - Функции для двусвязного списка:
     - Добавление в начало:
       ```c
       DNode* pushFrontD(DNode* head, int value) {
           DNode* newNode = malloc(sizeof(DNode));
           newNode->data = value;
           newNode->prev = NULL;
           newNode->next = head;
           if (head != NULL) {
               head->prev = newNode;
           }
           return newNode;
       }
       ```
     - Печать списка в прямом и обратном направлении:
       ```c
       void printDListForward(DNode* head) {
           DNode* current = head;
           while (current != NULL) {
               printf("%d <-> ", current->data);
               current = current->next;
           }
           printf("NULL\n");
       }
       ```
   
8. **Функции внутри структур (функциональные указатели)**  
   - В C нельзя "прямо" определять методы внутри структур, но можно хранить указатели на функции.  
   - Пример структуры, хранящей указатели на функции:
     ```c
     typedef struct {
         int x;
         int y;
         void (*print)(int, int);
     } Character;
     ```
   - Мы можем определять функцию, а затем присвоить её указатель:
     ```c
     void printCoords(int x, int y) {
         printf("Coords: (%d, %d)\n", x, y);
     }

     Character c = {0, 0, printCoords};
     c.print(c.x, c.y);
     ```

   Это подготавливает почву для создания более сложных структур данных, таких как объекты игры.
   

## Первое задание

Нужно отсортировать список точек относительно центра

Точки: (0, 0), (3, 4), (1, -1), (-2, 2), (5, 5), (-3, 0), (10, -10), (6, -2), (9, 1), (7, -7)

ответ
Ниже приведена транспонированная таблица. Теперь названия строк и столбцов поменялись местами.

|              | (0, 0) | (1, -1)    | (-2, 2)     | (-3, 0) | (3, 4) | (6, -2)     | (5, 5)      | (9, 1)      | (7, -7)     | (10, -10)    |
|--------------|---------|------------|-------------|---------|--------|-------------|-------------|-------------|-------------|--------------|
| Расстояние   | 0       | 1.414 | 2.828  | 3       | 5      | 6.324 | 7.071 | 9.055 | 9.899 | 14.142 |


## ДЗ 2
Доработать код `game.c`

1. Вместо фиксированного массива поля использовать динамически выделенную память.  
2. Враги должны не случайно перемещаться, а идти в сторону игрока.  
3. После выхода из комнаты создать новую комнату с на один враг больше, чем было в предыдущей.