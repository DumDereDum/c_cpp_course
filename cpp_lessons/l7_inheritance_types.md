В C++ модификаторы доступа `public`, `private` и `protected` применяются к членам класса и управляют их доступом из других частей программы. 

## Пример 1: Public (публичное наследование переменных):
- При публичном наследовании все открытые члены базового класса остаются открытыми для производного класса.
- Производный класс имеет доступ ко всем открытым членам базового класса, как если бы они были определены внутри производного класса.
```c++
class Base {
public:
    int x;
};

class Derived : public Base {
public:
    int y;
};

int main() {
    Derived d;
    d.x = 10; // Доступ к члену x из производного класса
    d.y = 20;
    return 0;
}
```

## Пример 2: Protected (защищенное наследование переменных):
- При защищенном наследовании все открытые и защищенные члены базового класса становятся защищенными в производном классе.
- Защищенные члены базового класса недоступны извне, но они доступны в производном классе и его методах.

```cpp
class Base {
protected:
    int x;
public:
    int z;
};

class Derived : protected Base {
public:
    int y;
};

int main() {
    Derived d;
    d.x = 10; // Недоступно, так как x защищен в производном классе
    d.y = 20;
    d.z = 30; // Недоступно, так как x защищен в производном классе
    return 0;
}
```

## Пример 3: Private (частное наследование переменных):
- При частном наследовании все открытые и защищенные члены базового класса становятся частными в производном классе.
- Частные члены базового класса недоступны извне и недоступны в производном классе.

```cpp
class Base {
private:
    int x;
public:
    int z;
protected:
    int k;
};

class Derived : private Base {
public:
    int y;
};

int main() {
    Derived d;
    d.x = 10; // Недоступно, так как x является частным в производном классе
    d.y = 20;
    d.z = 30; // Недоступно, так как x защищен в производном классе
    d.k = 40; // Недоступно, так как x является частным в производном классе
    return 0;
}
```

## Пример 4: Public наследование Protected функции:

```C++
class Unit
{
protected:
	void Move() {}
};
class Rabbit :public Unit {
public:
	void MoveForGrass() { Move(); }
};

int main()
{
	Rabbit r;
	r.MoveForGrass();
	r.Move(); // Недоступно, так как Unit.Move() защищен в производном классе
}
```

В данном коде определен базовый класс `Unit` с защищенным методом `Move()`, который доступен только для классов-наследников и самого базового класса. Затем определен производный класс `Rabbit`, который наследуется от `Unit` публичным способом. У класса `Rabbit` есть метод `MoveForGrass()`, который вызывает метод `Move()` из класса `Unit`.

В функции `main()` создается объект `Rabbit` с именем `r`. Мы можем вызывать метод `MoveForGrass()`, так как он публичный, но не можем вызвать метод `Move()` напрямую из `main()`, так как он защищен и не доступен извне класса.

## Пример 5: Public наследование Employee <- Manager <- Supervisor

```C++
#include <iostream>
using namespace std;

class Date { };

class Employee {
public:
    Date GetFire() const;
protected:
    void Bonus(double sum);
};

class Manager: public Employee {
    double f() { return 1000; }
public:
    bool SetBonus() { return false; }
};

class Supervisor: public Manager { };

void test(Employee *emp, Manager *mng, Supervisor *sup) {
    sup->Bonus(5000); // Ошибка, метод Bonus() защищен и недоступен извне класса Employee

    emp->GetFire();
    mng->GetFire();
    sup->GetFire();

    emp = mng;
    emp = sup;
    mng = sup; 

    sup = emp; // Ошибка, нельзя присвоить объект Employee объекту Supervisor
    mng = emp; // Ошибка, нельзя присвоить объект Employee объекту Manager
    sup = mng; // Ошибка, нельзя присвоить объект Manager объекту Supervisor
}

int main() {
    return 0;
}
```

Давайте разберем ваш код:

1. В коде определены классы `Date`, `Employee`, `Manager` и `Supervisor`.
2. В классе `Employee` определен метод `GetFire()`, который возвращает объект класса `Date`, и защищенный метод `Bonus(double sum)`.
3. Класс `Manager` наследует класс `Employee` публично и определяет свой собственный метод `SetBonus()`, который возвращает логическое значение `false`.
4. Класс `Supervisor` наследует класс `Manager`.
5. В функции `test` создаются указатели на объекты классов `Employee`, `Manager` и `Supervisor`.
6. Внутри функции `test` происходят следующие операции:

    - `sup->Bonus(5000);` вызывает ошибку, потому что метод `Bonus()` защищен и недоступен извне класса `Employee`.
    - `emp->GetFire();`, `mng->GetFire();`, `sup->GetFire();` - вызов метода `GetFire()` для каждого из объектов. Этот метод доступен для вызова, так как он объявлен как `public` в классе `Employee`.
    - Присваивание объектов друг другу (`emp = mng;`, `emp = sup;`, `mng = sup;`) является допустимым, так как указатели имеют типы, которые являются частью иерархии наследования.
    - `sup = emp;`, `mng = emp;`, `sup = mng;` - вызывают ошибки, потому что указатели на объекты класса `Employee`, `Manager` и `Supervisor` не могут быть назначены друг другу из-за их типов.


## Пример 6: Private наследование функций

```C++
class A
{
public:
	void f() {}
	void g() {}
};

class B : private A { };

void fun(A * a) { a->f(); }

int main() {
	A a;
	B b;
	a.g();
	b.f(); // Ошибка, метод f() является частным в производном классе
	fun(&a);
	fun(&b); // Ошибка, метод f() является частным в производном классе и недотупен в fun(A*a)
}
```
Давайте разберем код:

1. В коде определены классы `A` и `B`.
2. Класс `A` содержит два публичных метода: `f()` и `g()`.
3. Класс `B` наследует класс `A` приватно, что означает, что все публичные и защищенные члены `A` становятся приватными для `B`.
4. В функции `fun` передается указатель на объект класса `A`, который используется для вызова метода `f()`.

Теперь рассмотрим каждую строку в функции `main()`:

- `A a;` - создается объект класса `A`.
- `B b;` - создается объект класса `B`. Но поскольку `B` приватно наследует от `A`, методы `f()` и `g()` в классе `A` становятся приватными в классе `B`.
- `a.g();` - вызывается метод `g()` объекта `a`, что является допустимым, так как метод `g()` является публичным в классе `A`.
- `b.f();` - вызывает ошибку компиляции, так как метод `f()` является частным в классе `B`.
- `fun(&a);` - передается указатель на объект `a`, который является объектом класса `A`. Метод `f()` может быть вызван, так как он публичный в классе `A`.
- `fun(&b);` - вызывает ошибку компиляции, так как объект функция `f()` будет ндоступна внутри функции `fun()`.

## Пример 6: Private наследование функций и изменение доступа

```C++
class A
{
public:
	void f() {}
protected:
	void g() {}
};

class B : private A {
public:
    A::g;
};

void fun(A * a) { a->f(); }

int main() {
	A a;
	B b;
	a.g(); // Ошибка, метод g() является защищенным
    b.g();
	b.f(); // Ошибка, метод f() является частным в производном классе
	fun(&a);
	fun(&b); // Ошибка, метод f() является частным в производном классе и недотупен в fun(A*a)
}
```
Давайте разберем код:

1. Класс `A` содержит два метода: `f()` (открытый) и `g()` (защищенный).
2. Класс `B` наследует класс `A` с модификатором доступа `private`, что делает все члены `A` приватными для `B`.
3. Внутри класса `B` происходит попытка сделать метод `g()` доступным для наследования с помощью `A::g;`.
4. Функция `fun(A *a)` пытается вызвать метод `f()` объекта типа `A`, но это вызовет ошибку, так как метод `f()` доступен только классу `A`.
5. В функции `main()` создаются объекты `A` и `B`, и попытки вызвать методы `g()` и `f()` вызовут ошибки из-за их доступности.


## Пример 7: 

```C++
class A
{
public:
	void f() {}
protected:
	void g() {}
};

class B : private A {
public:
	void foo() {
	    g();
	    A *p = this;	
    }
};

void fun(A * a) { a->f(); }

int main() {
	A a;
	B b;
	a.g(); // Ошибка, метод g() является защищенным
    b.foo();
	b.f(); // Ошибка, метод f() является частным в производном классе
	fun(&a);
	fun(&b); // Ошибка, метод f() является частным в производном классе и недотупен в fun(A*a)
}
```

Давайте разберем код:

1. Класс `A` содержит два метода: `f()` (публичный) и `g()` (защищенный).
2. Класс `B` наследует класс `A` с модификатором доступа `private`, что делает все члены `A` приватными для `B`.
3. Внутри класса `B` метод `foo()` вызывает метод `g()`, который является доступным, так как `B` является наследником `A`, но `g()` доступен только внутри класса `B`.

## Пример 8:

```C++
class A
{
public:
    void f() {}
protected:
    void g() {}
};

class B : private A {
public:
	A::g;
};

class C :public B {
public:

    void foo(){
        f(); // Ошибка, обращение к функции f() которое является приватным после наследования B : private A
        g();
        B* p = this;
        p->g();
        p->f(); // Ошибка, обращение к функции f() которое является приватным после наследования B : private A
        A* pa = this; // Ошибка, обращение к классу A которое является приватным после наследования B : private A
        pa->f();
    }
};

int main() {
	A a;
	B b;
	C c;
	a.g(); // Ошибка, protected функция класса A
	b.g();
	b.f(); // Ошибка, обращение к функции f() которое является приватным после наследования B : private A
	c.g();
}
```

## Пример 9: 

```C++
class Elem {
public:
    Elem(int maxAge_) : age(0), maxAge(maxAge_), x(0), y(0) {}
    bool Live() { return (++age != maxAge); }
    bool Eat();
    bool Move() { ChangeX(); ChangeY(); return true; }
private:
    bool IsDead() { return (age == maxAge); }
    int age, maxAge;
    int x, y;
    void ChangeX();
    void ChangeY();
};

class Rabbit : protected Elem {
public:
    Rabbit(int maxAge_, double v_) : Elem(maxAge_), v(v_) {}
    bool Live() { return Elem::Live() && Eat() && Elem::Move(); }
protected:
    bool Eat();
private:
    double v;
};

int main() {
    Rabbit r(5, 27);
    r.Live();
    r.Move();
    r.Eat();
}
```

