# Шаблоны и дружественность

```cpp
#include <iostream>
template<class T>class A; 
template<class T>
class B {
	friend class A<T>;
	T t;
public:
	B(T a) :t(a) {}
};

template<class T>
class A {
public:
     void test(B<T>& b) { 
          std::cout << b.t << std::endl; 
     } 
};

int main() {
	B<int> b(7);
	A<int> a;
	a.test(b);
	A<double> a1;
	a1.test(b); //ошибка
}
```
Этот код демонстрирует дружественные отношения между шаблонными классами `A` и `B`.

- Класс `B` содержит член `t` и конструктор для инициализации этого члена.
- Класс `A` имеет метод `test`, который принимает объект класса `B` по ссылке и выводит значение его члена `t`.
- Класс `B` объявляется дружественным для класса `A` с помощью строки `friend class A<T>;`, позволяя классу `A` иметь доступ к приватным членам `B`.
- В функции `main` создается объект `b` типа `B<int>`, затем создается объект `a` типа `A<int>`, и метод `test` вызывается для объекта `a`, используя объект `b`.
- Закомментированная строка в функции `main` приводит к ошибке, так как класс `A<double>` не имеет доступа к приватным членам класса `B<int>`.

---


```cpp
#include <iostream>
template<class T>class A; 
template<class T>
class B {
	template <class X> friend class A;
	T t;
public:
	B(T a) :t(a) {}
};
template<class T>
class A {
public:
     template <class X> void test(B<X>& b) { 
          std::cout << b.t << std::endl; 
     } 
};
int main() {
	 B<int> b(7);
	 A<double> a;
	 a.test(b); 	
}
```
Этот код демонстрирует использование шаблонных классов и дружественных функций в C++.

- Класс `B` имеет шаблонный член `t` и конструктор для его инициализации.
- Класс `A` содержит метод `test`, который является шаблонным и принимает объект класса `B` по ссылке.
- Строка `template <class X> friend class A;` в классе `B` делает класс `A` дружественным для всех экземпляров класса `B`.
- В функции `main` создается объект `b` типа `B<int>`, а затем создается объект `a` типа `A<double>`. Метод `test` вызывается для объекта `a`, используя объект `b`.

Основная идея кода - продемонстрировать, как шаблонные классы могут быть дружественными друг к другу, и как шаблонные методы могут быть использованы для работы с различными типами данных.
