# Шаблоны вложенных классов

```cpp
class A {};

class X{
    template <class T>
    class Nested{
        T a;
    };
    Nested<int> i;
    Nested<char> c;
    Nested<A> a;
};

int main(){
    X x;
}
```
Этот код определяет класс `X`, который содержит вложенный шаблонный класс `Nested`. Класс `Nested` является шаблонным и параметризуется типом `T`. Внутри класса `Nested` есть переменная `a` типа `T`.

В классе `X` создаются три экземпляра класса `Nested` с различными параметрами типа:
1. `Nested<int> i;` - создается экземпляр `i` класса `Nested`, где `T` заменен на `int`.
2. `Nested<char> c;` - создается экземпляр `c` класса `Nested`, где `T` заменен на `char`.
3. `Nested<A> a;` - создается экземпляр `a` класса `Nested`, где `T` заменен на пользовательский тип `A`.

Код в функции `main` создает объект класса `X`.

---

```cpp
#include <iostream>

template <class Y>
class X{
    template <class T>
    class Nested{
        T a;
    public:
        T& get();
    };
public:
    Nested<int> i;
    X(Y y){
        i.get() = y;
    }
};

template <class Y>
template <class T>
T& X<Y>::Nested<T>::get()
{
    return a;
}

int main()
{
    X<char> x('a');
    std::cout << x.i.get() << std::endl; // 97
}
```

Этот код определяет шаблонный класс `X`, который содержит вложенный шаблонный класс `Nested`. Класс `Nested` имеет приватное поле `a` типа `T`.

В классе `X` создается объект `i` класса `Nested<int>`.

В конструкторе класса `X` принимается аргумент типа `Y` (в данном случае `char`). В конструкторе объект `i` класса `Nested<int>` присваивается значение аргумента `y`, вызывая метод `get()` объекта `i` и присваивая ему значение аргумента `y`.

Метод `get()` класса `Nested` возвращает ссылку на поле `a`.

В функции `main` создается объект `x` класса `X<char>` с аргументом `'a'`. Затем выводится значение поля `a` объекта `i` класса `x`, которое равно 97 (ASCII-код символа `'a'`).
