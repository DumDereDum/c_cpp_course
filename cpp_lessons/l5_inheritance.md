# inheritance
**[КОД](cpp_examples/Forms)**

Наследование в C++ является одним из основных принципов объектно-ориентированного программирования (ООП) и позволяет создавать иерархии классов, где производные классы могут наследовать свойства и методы базовых классов. Это позволяет повторно использовать код, упрощает его структурирование и обеспечивает полиморфизм.

## Конструкторы

В C++ конструкторы в наследовании играют важную роль, поскольку они обеспечивают корректную инициализацию объектов в целом и связанных с ними классов в частности. Когда происходит наследование, конструкторы базового класса и производного класса имеют свои особенности.

### 1. Конструктор по умолчанию (без параметров):
Если в базовом классе определен конструктор по умолчанию и в производном классе не определен явно ни один конструктор, то компилятор автоматически вызывает конструктор по умолчанию базового класса.

### 2. Конструктор с параметрами:
Если в базовом классе определен конструктор с параметрами, то в производном классе нужно явно вызвать соответствующий конструктор базового класса в списке инициализации конструктора производного класса.
Пример:

```C++
class Base {
public:
    Base(int x) {
        // код инициализации
    }
};

class Derived : public Base {
public:
    Derived(int x, int y) : Base(x) {
        // код инициализации производного класса
    }
};
```

### Список инициализации базового класса
В конструкторе производного класса в списке инициализации вызывается конструктор базового класса с необходимыми параметрами.

### Тело конструктора:
После инициализации базового класса инициализируются свойства самого производного класса, если это необходимо.

### Важные замечания:
* Порядок инициализации в конструкторе производного класса следует порядку наследования.
* Если конструктор базового класса не вызван явно в списке инициализации конструктора производного класса, будет вызван конструктор по умолчанию базового класса.


## Деструкторы

Деструкторы в наследовании в C++ играют важную роль в управлении ресурсами и освобождении памяти, выделенной для объектов. Когда объект выходит из области видимости или уничтожается оператором delete, вызывается его деструктор для освобождения ресурсов, которые он может занимать.

### Вызов деструкторов в цепочке наследования:
При наследовании каждый деструктор вызывается в порядке обратном порядку вызова конструкторов.

### Деструкторы виртуальные:
Важно объявлять деструкторы в базовом классе виртуальными, если вы планируете использовать полиморфизм (динамическое связывание) для уничтожения объектов производных классов через указатель на базовый класс. Это гарантирует, что вызывается деструктор того класса, к которому принадлежит объект, даже если через указатель на базовый класс.

```C++
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor of Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor of Base" << endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        cout << "Constructor of Derived" << endl;
    }
    ~Derived() {
        cout << "Destructor of Derived" << endl;
    }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;
    return 0;
}
```
Результат:
```
Constructor of Base
Constructor of Derived
Destructor of Derived
Destructor of Base
```

### Замечание

Можно объявить деструктор класса производного (Derived) класса как виртуальный, и это будет работать так же, как и если бы он был объявлен в базовом классе. Однако важно понимать разницу между обычным деструктором и виртуальным деструктором в контексте наследования и полиморфизма.

Вот основные различия:

#### Обычный деструктор:

* Обычный деструктор выполняет освобождение ресурсов, выделенных для объекта этого класса.
* Если производный класс (Derived) не объявляет свой деструктор как виртуальный, и объекты этого класса будут удаляться через указатель на базовый класс, возможно неправильное поведение при освобождении ресурсов. Деструктор базового класса будет вызван, но деструктор производного класса - нет.

#### Виртуальный деструктор:

* Виртуальный деструктор в базовом классе гарантирует, что при удалении объекта через указатель на базовый класс будет вызван соответствующий деструктор производного класса.
* Если класс базового класса (Base) объявлен как виртуальный, то деструкторы всех производных классов (Derived) вызываются при удалении объекта через указатель на базовый класс.


## Виртуальные функции

В C++ виртуальные функции - это механизм, позволяющий реализовывать полиморфизм, то есть обеспечивать вызов функции, соответствующей типу объекта во время выполнения программы. Виртуальные функции важны в иерархиях классов, где производные классы могут переопределять методы базового класса.


### Синтаксис:

```C++
class Base {
public:
    virtual void myFunction() {
        // реализация базовой версии функции
    }
};

class Derived : public Base {
public:
    void myFunction() override {
        // реализация переопределенной версии функции
    }
};
```

### Ключевое слово override:

Используется для явного указания, что функция в производном классе переопределяет виртуальную функцию из базового класса. Позволяет компилятору обнаружить ошибки, связанные с неправильным переопределением функций.

### Механизм позднего связывания:

При использовании виртуальных функций объекты вызывают методы, соответствующие их конкретному типу во время выполнения программы. Это называется поздним связыванием.

### Динамическое связывание:

Для виртуальных функций выполняется динамическое связывание, которое означает, что вызов метода определяется во время выполнения, а не во время компиляции.

## Чистые фиртуальные функции

Когда виртуальная функция объявлена с = 0, это означает, что эта функция является чистой виртуальной функцией (pure virtual function). Подобные функции не имеют реализации в классе, в котором они объявлены, и должны быть переопределены в производных классах.

### Использование чистых виртуальных функций полезно в следующих случаях:

* **Абстрактные классы:** Класс, содержащий хотя бы одну чистую виртуальную функцию, становится абстрактным классом. Такие классы предназначены для предоставления интерфейса для производных классов и не могут быть созданы напрямую.

* **Интерфейсы:** Чистые виртуальные функции используются для определения интерфейсов, предоставляя базовую структуру для производных классов. Каждый производный класс должен реализовать чистые виртуальные функции.

